@using System.Threading
@using Microsoft.JSInterop
@using Soenneker.Blazor.Extensions.EventCallback
@using Soenneker.Blazor.Floating.Windows.Abstract
@using Soenneker.Blazor.Floating.Windows.Options
@using Soenneker.Extensions.Task
@using Soenneker.Extensions.ValueTask

@inject IFloatingWindowInterop WindowInterop

@implements IFloatingWindow

<div id="@ElementId" class="floating-window @(_visible ? "visible" : "")" @attributes="WindowAttributes">
    @if (MergedOptions.ShowTitleBar)
    {
        <div class="floating-window-titlebar" >
            <div class="floating-window-title" >@(MergedOptions.Title ?? "Window")</div>
            @if (MergedOptions.ShowCloseButton)
            {
                <button class="floating-window-close" type="button" aria-label="Close" >
                    <span>&times;</span>
                </button>
            }
        </div>
    }

    <div class="floating-window-content" >
        @ChildContent
    </div>

    @if (MergedOptions.Resizable)
    {
        <div class="floating-window-resize-handle resize-n" data-direction="n" ></div>
        <div class="floating-window-resize-handle resize-e" data-direction="e" ></div>
        <div class="floating-window-resize-handle resize-s" data-direction="s" ></div>
        <div class="floating-window-resize-handle resize-w" data-direction="w" ></div>
        <div class="floating-window-resize-handle resize-ne" data-direction="ne" ></div>
        <div class="floating-window-resize-handle resize-nw" data-direction="nw" ></div>
        <div class="floating-window-resize-handle resize-se" data-direction="se" ></div>
        <div class="floating-window-resize-handle resize-sw" data-direction="sw" ></div>
    }
</div>

@code {

    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object?>? WindowAttributes { get; set; }

    [Parameter]
    public RenderFragment ChildContent { get; set; } = null!;

    [Parameter]
    public string ElementId { get; set; } = "fw-" + Guid.NewGuid();

    [Parameter]
    public EventCallback OnShow { get; set; }

    [Parameter]
    public EventCallback OnHide { get; set; }

    [Parameter]
    public EventCallback OnDragStart { get; set; }

    [Parameter]
    public EventCallback OnDragEnd { get; set; }

    [Parameter]
    public FloatingWindowOptions Options { get; set; } = new();

    [Parameter]
    public bool? Draggable { get; set; }

    [Parameter]
    public bool? Resizable { get; set; }

    [Parameter]
    public bool? ShowCloseButton { get; set; }

    [Parameter]
    public bool? ShowTitleBar { get; set; }

    [Parameter]
    public string? Title { get; set; }

    [Parameter]
    public bool? Enabled { get; set; }

    [Parameter]
    public int? Width { get; set; }

    [Parameter]
    public int? Height { get; set; }

    [Parameter]
    public int? InitialX { get; set; }

    [Parameter]
    public int? InitialY { get; set; }

    [Parameter]
    public bool? UseCdn { get; set; }

    private FloatingWindowOptions MergedOptions => new()
    {
        Draggable = Draggable ?? Options.Draggable,
        Resizable = Resizable ?? Options.Resizable,
        ShowCloseButton = ShowCloseButton ?? Options.ShowCloseButton,
        ShowTitleBar = ShowTitleBar ?? Options.ShowTitleBar,
        Title = Title ?? Options.Title,
        Enabled = Enabled ?? Options.Enabled,
        Width = Width ?? Options.Width,
        Height = Height ?? Options.Height,
        InitialX = InitialX ?? Options.InitialX,
        InitialY = InitialY ?? Options.InitialY,
        MinWidth = Options.MinWidth,
        MinHeight = Options.MinHeight,
        MaxWidth = Options.MaxWidth,
        MaxHeight = Options.MaxHeight,
        ConstrainToViewport = Options.ConstrainToViewport,
        CenterOnShow = Options.CenterOnShow,
        FocusOnShow = Options.FocusOnShow,
        UseCdn = UseCdn ?? Options.UseCdn,
        ZIndex = Options.ZIndex
    };

    private bool _initialized;
    private bool _visible;
    private readonly CancellationTokenSource _disposeCts = new();
    private DotNetObjectReference<FloatingWindow>? _dotNetRef;

    [JSInvokable]
    public async Task InvokeOnShow()
    {
        _visible = true;
        await OnShow.InvokeIfHasDelegate().NoSync();
    }

    [JSInvokable]
    public async Task InvokeOnHide()
    {
        _visible = false;
        await OnHide.InvokeIfHasDelegate().NoSync();
    }

    [JSInvokable]
    public async Task InvokeOnDragStart()
    {
        await OnDragStart.InvokeIfHasDelegate().NoSync();
    }

    [JSInvokable]
    public async Task InvokeOnDragEnd()
    {
        await OnDragEnd.InvokeIfHasDelegate().NoSync();
    }

    private async Task OnTitleBarMouseDown()
    {
        if (MergedOptions.Draggable)
        {
            await WindowInterop.BringToFront(ElementId, _disposeCts.Token);
        }
    }

    private async Task OnCloseClick()
    {
        await Close();
    }

    private async Task OnResizeMouseDown()
    {
        await WindowInterop.BringToFront(ElementId, _disposeCts.Token);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await WindowInterop.Initialize(MergedOptions.UseCdn, _disposeCts.Token).NoSync();
            _dotNetRef = DotNetObjectReference.Create(this);

            await WindowInterop.Create(ElementId, MergedOptions, _disposeCts.Token).NoSync();
            await WindowInterop.SetCallbacks(ElementId, _dotNetRef!).NoSync();

            // Set initialized after everything is done
            _initialized = true;
            StateHasChanged();

            if (MergedOptions.CenterOnShow)
            {
                await CenterWindow();
            }
        }
    }

    private async Task CenterWindow()
    {
        try
        {
            (int width, int height) windowSize = await WindowInterop.GetSize(ElementId, _disposeCts.Token);
            (int width, int height) viewportSize = await WindowInterop.GetViewportSize(_disposeCts.Token);

            int x = (viewportSize.width - windowSize.width) / 2;
            int y = (viewportSize.height - windowSize.height) / 2;

            await WindowInterop.SetPosition(ElementId, x, y, _disposeCts.Token);
        }
        catch
        {
            // Fallback to default positioning
        }
    }

    public async ValueTask Show()
    {
        Console.WriteLine($"Show() called for window {ElementId}, initialized: {_initialized}");
        if (_initialized)
        {
            await WindowInterop.Show(ElementId, _disposeCts.Token);
            _visible = true;
            Console.WriteLine($"Window {ElementId} shown successfully");
        }
        else
        {
            Console.WriteLine($"Window {ElementId} not initialized yet");
        }
    }

    public async ValueTask Hide()
    {
        if (_initialized)
        {
            await WindowInterop.Hide(ElementId, _disposeCts.Token);
            _visible = false;
        }
    }

    public async ValueTask Toggle()
    {
        if (_initialized)
        {
            await WindowInterop.Toggle(ElementId, _disposeCts.Token);
            _visible = !_visible;
        }
    }

    public async ValueTask Close()
    {
        if (_initialized)
        {
            await WindowInterop.Close(ElementId, _disposeCts.Token);
            _visible = false;
        }
    }

    public async ValueTask<(int x, int y)> GetPosition()
    {
        if (_initialized)
        {
            return await WindowInterop.GetPosition(ElementId, _disposeCts.Token);
        }

        return (0, 0);
    }

    public async ValueTask SetPosition(int x, int y)
    {
        if (_initialized)
        {
            await WindowInterop.SetPosition(ElementId, x, y, _disposeCts.Token);
        }
    }

    public async ValueTask<(int width, int height)> GetSize()
    {
        if (_initialized)
        {
            return await WindowInterop.GetSize(ElementId, _disposeCts.Token);
        }

        return (0, 0);
    }

    public async ValueTask SetSize(int width, int height)
    {
        if (_initialized)
        {
            await WindowInterop.SetSize(ElementId, width, height, _disposeCts.Token);
        }
    }

    public async ValueTask DisposeAsync()
    {
        GC.SuppressFinalize(this);

        await _disposeCts.CancelAsync().NoSync();
        await WindowInterop.Destroy(ElementId, CancellationToken.None);

        _dotNetRef?.Dispose();
        _disposeCts.Dispose();
    }

}