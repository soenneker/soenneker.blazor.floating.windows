@using System.Threading
@using Microsoft.JSInterop
@using Soenneker.Extensions.String
@using Soenneker.Blazor.Extensions.EventCallback
@using Soenneker.Blazor.Floating.Windows.Abstract
@using Soenneker.Blazor.Floating.Windows.Options
@using Soenneker.Extensions.Task
@using Soenneker.Extensions.ValueTask

@inject IFloatingWindowInterop WindowInterop

@implements IFloatingWindow

<CascadingValue Value="this" >
    <div id="@($"anchor-{Id}")" class="floating-Window-anchor" @attributes="AnchorAttributes" >
        @ChildContent
    </div>

    @if (_initialized)
    {
        <div id="@($"Window-{Id}")" @attributes="WindowAttributes" >
            @ResolvedContent
        </div>
    }
</CascadingValue>

@code {

    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object?>? WindowAttributes { get; set; }

    [Parameter]
    public Dictionary<string, object?>? AnchorAttributes { get; set; }

    [Parameter]
    public RenderFragment ChildContent { get; set; } = null!;

    private RenderFragment? _WindowContent;

    [Parameter]
    public string? Text { get; set; }

    [Parameter]
    public string Id { get; set; } = "ft-" + Guid.NewGuid();

    [Parameter]
    public EventCallback OnShow { get; set; }

    [Parameter]
    public EventCallback OnHide { get; set; }

    [Parameter]
    public FloatingWindowOptions Options { get; set; } = new();

    [Parameter]
    public bool? Animate { get; set; }

    [Parameter]
    public int? ShowDelay { get; set; }

    [Parameter]
    public int? HideDelay { get; set; }

    [Parameter]
    public bool? ShowArrow { get; set; }

    [Parameter]
    public bool? Interactive { get; set; }

    [Parameter]
    public bool? Enabled { get; set; }

    [Parameter]
    public int? MaxWidth { get; set; }

    [Parameter]
    public bool? ManualTrigger { get; set; }

    [Parameter]
    public bool? UseCdn { get; set; }

    private FloatingWindowOptions MergedOptions => new()
    {
        Animate = Animate ?? Options.Animate,
        ShowDelay = ShowDelay ?? Options.ShowDelay,
        HideDelay = HideDelay ?? Options.HideDelay,
        ShowArrow = ShowArrow ?? Options.ShowArrow,
        Interactive = Interactive ?? Options.Interactive,
        Enabled = Enabled ?? Options.Enabled,
        MaxWidth = MaxWidth ?? Options.MaxWidth,
        ManualTrigger = ManualTrigger ?? Options.ManualTrigger,
        UseCdn = UseCdn ?? Options.UseCdn
    };

    private bool _initialized;
    private bool _createPending;
    private readonly CancellationTokenSource _disposeCts = new();
    private DotNetObjectReference<FloatingWindow>? _dotNetRef;

    private RenderFragment? ResolvedContent =>
        _WindowContent != null
            ? _WindowContent
            : (Text.HasContent()
                ? (__builder =>
                {
                    __builder.OpenElement(0, "div");
                    __builder.AddAttribute(1, "class", "Window-text");
                    __builder.AddContent(2, Text);
                    __builder.CloseElement();
                })
                : null);

    [JSInvokable]
    public async Task InvokeOnShow()
    {
        await OnShow.InvokeIfHasDelegate().NoSync();
    }

    [JSInvokable]
    public async Task InvokeOnHide()
    {
        await OnHide.InvokeIfHasDelegate().NoSync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await WindowInterop.Initialize(MergedOptions.UseCdn, _disposeCts.Token).NoSync();
            _dotNetRef = DotNetObjectReference.Create(this);
            _initialized = true;
            _createPending = true;
            StateHasChanged();
            return;
        }

        if (_createPending)
        {
            _createPending = false;
            await WindowInterop.Create(Id, MergedOptions, _disposeCts.Token).NoSync();
            await WindowInterop.SetCallbacks(Id, _dotNetRef!).NoSync();
        }
    }

    public async ValueTask Show()
    {
        if (_initialized)
            await WindowInterop.Show(Id);
    }

    public async ValueTask Hide()
    {
        if (_initialized)
            await WindowInterop.Hide(Id);
    }

    public async ValueTask Toggle()
    {
        if (_initialized)
            await WindowInterop.Toggle(Id);
    }

    protected override void OnParametersSet()
    {
        if (_WindowContent != null && Text.HasContent())
        {
            throw new InvalidOperationException("Both WindowContent and Text were set. Use only one.");
        }
    }

    public void SetWindowContent(RenderFragment content)
    {
        _WindowContent = content;
    }

    public async ValueTask DisposeAsync()
    {
        GC.SuppressFinalize(this);

        await _disposeCts.CancelAsync().NoSync();
        await WindowInterop.Destroy(Id, CancellationToken.None);

        _dotNetRef?.Dispose();
        _disposeCts.Dispose();
    }
}